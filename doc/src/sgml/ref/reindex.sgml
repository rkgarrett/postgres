<!--
doc/src/sgml/ref/reindex.sgml
PostgreSQL documentation
-->

<refentry id="SQL-REINDEX">
 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>REINDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>rebuild indexes</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
REINDEX { INDEX | TABLE | DATABASE | SYSTEM } [ CONCURRENTLY ] <replaceable class="PARAMETER">name</replaceable> [ FORCE ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>REINDEX</command> rebuilds an index using the data
   stored in the index's table, replacing the old copy of the index. There are
   several scenarios in which to use <command>REINDEX</command>:

   <itemizedlist>
    <listitem>
     <para>
      An index has become corrupted, and no longer contains valid
      data. Although in theory this should never happen, in
      practice indexes can become corrupted due to software bugs or
      hardware failures.  <command>REINDEX</command> provides a
      recovery method.
     </para>
    </listitem>

    <listitem>
     <para>
      An index has become <quote>bloated</>, that is it contains many
      empty or nearly-empty pages.  This can occur with B-tree indexes in
      <productname>PostgreSQL</productname> under certain uncommon access
      patterns. <command>REINDEX</command> provides a way to reduce
      the space consumption of the index by writing a new version of
      the index without the dead pages. See <xref
      linkend="routine-reindex"> for more information.
     </para>
    </listitem>

    <listitem>
     <para>
      You have altered a storage parameter (such as fillfactor)
      for an index, and wish to ensure that the change has taken full effect.
     </para>
    </listitem>

    <listitem>
     <para>
      An index build with the <literal>CONCURRENTLY</> option failed, leaving
      an <quote>invalid</> index. Such indexes are useless but it can be
      convenient to use <command>REINDEX</> to rebuild them. Note that
      <command>REINDEX</> will perform a concurrent build if <literal>
      CONCURRENTLY</> is specified. To build the index without interfering
      with production you should drop the index and reissue either the
      <command>CREATE INDEX CONCURRENTLY</> or <command>REINDEX CONCURRENTLY</>
      command. Indexes of toast relations can be rebuilt with <command>REINDEX
      CONCURRENTLY</>.
     </para>
    </listitem>

   </itemizedlist></para>
 </refsect1>

 <refsect1>
  <title>Parameters</title>

  <variablelist>
   <varlistentry>
    <term><literal>INDEX</literal></term>
    <listitem>
     <para>
      Recreate the specified index.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLE</literal></term>
    <listitem>
     <para>
      Recreate all indexes of the specified table.  If the table has a
      secondary <quote>TOAST</> table, that is reindexed as well.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DATABASE</literal></term>
    <listitem>
     <para>
      Recreate all indexes within the current database.
      Indexes on shared system catalogs are also processed.
      This form of <command>REINDEX</command> cannot be executed inside a
      transaction block.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SYSTEM</literal></term>
    <listitem>
     <para>
      Recreate all indexes on system catalogs within the current database.
      Indexes on shared system catalogs are included.
      Indexes on user tables are not processed.
      This form of <command>REINDEX</command> cannot be executed inside a
      transaction block.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">name</replaceable></term>
    <listitem>
     <para>
      The name of the specific index, table, or database to be
      reindexed.  Index and table names can be schema-qualified.
      Presently, <command>REINDEX DATABASE</> and <command>REINDEX SYSTEM</>
      can only reindex the current database, so their parameter must match
      the current database's name.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONCURRENTLY</literal></term>
    <listitem>
     <para>
      When this option is used, <productname>PostgreSQL</> will rebuild the
      index without taking any locks that prevent concurrent inserts,
      updates, or deletes on the table; whereas a standard reindex build
      locks out writes (but not reads) on the table until it's done.
      There are several caveats to be aware of when using this option
      &mdash; see <xref linkend="SQL-REINDEX-CONCURRENTLY"
      endterm="SQL-REINDEX-CONCURRENTLY-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FORCE</literal></term>
    <listitem>
     <para>
      This is an obsolete option; it is ignored if specified.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   If you suspect corruption of an index on a user table, you can
   simply rebuild that index, or all indexes on the table, using
   <command>REINDEX INDEX</command> or <command>REINDEX TABLE</command>.
  </para>

  <para>
   Things are more difficult if you need to recover from corruption of
   an index on a system table.  In this case it's important for the
   system to not have used any of the suspect indexes itself.
   (Indeed, in this sort of scenario you might find that server
   processes are crashing immediately at start-up, due to reliance on
   the corrupted indexes.)  To recover safely, the server must be started
   with the <option>-P</option> option, which prevents it from using
   indexes for system catalog lookups.
  </para>

  <para>
   One way to do this is to shut down the server and start a single-user
   <productname>PostgreSQL</productname> server
   with the <option>-P</option> option included on its command line.
   Then, <command>REINDEX DATABASE</>, <command>REINDEX SYSTEM</>,
   <command>REINDEX TABLE</>, or <command>REINDEX INDEX</> can be
   issued, depending on how much you want to reconstruct.  If in
   doubt, use <command>REINDEX SYSTEM</> to select
   reconstruction of all system indexes in the database.  Then quit
   the single-user server session and restart the regular server.
   See the <xref linkend="app-postgres"> reference page for more
   information about how to interact with the single-user server
   interface.
  </para>

  <para>
   Alternatively, a regular server session can be started with
   <option>-P</option> included in its command line options.
   The method for doing this varies across clients, but in all
   <application>libpq</>-based clients, it is possible to set
   the <envar>PGOPTIONS</envar> environment variable to <literal>-P</>
   before starting the client.  Note that while this method does not
   require locking out other clients, it might still be wise to prevent
   other users from connecting to the damaged database until repairs
   have been completed.
  </para>

  <para>
   <command>REINDEX</command> is similar to a drop and recreate of the index
   in that the index contents are rebuilt from scratch.  However, the locking
   considerations are rather different.  <command>REINDEX</> locks out writes
   but not reads of the index's parent table.  It also takes an exclusive lock
   on the specific index being processed, which will block reads that attempt
   to use that index.  In contrast, <command>DROP INDEX</> momentarily takes
   an exclusive lock on the parent table, blocking both writes and reads.  The
   subsequent <command>CREATE INDEX</> locks out writes but not reads; since
   the index is not there, no read will attempt to use it, meaning that there
   will be no blocking but reads might be forced into expensive sequential
   scans.
  </para>

  <para>
   Reindexing a single index or table requires being the owner of that
   index or table.  Reindexing a database requires being the owner of
   the database (note that the owner can therefore rebuild indexes of
   tables owned by other users).  Of course, superusers can always
   reindex anything.
  </para>

  <refsect2 id="SQL-REINDEX-CONCURRENTLY">
   <title id="SQL-REINDEX-CONCURRENTLY-title">Rebuilding Indexes Concurrently</title>

   <indexterm zone="SQL-REINDEX-CONCURRENTLY">
   <primary>index</primary>
   <secondary>rebuilding concurrently</secondary>
   </indexterm>

   <para>
    Rebuilding an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</> locks the table whose index is rebuilt
    against writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index rebuild is finished. This could have a severe effect if the system is
    a live production database. Very large tables can take many hours to be
    indexed, and even for smaller tables, an index rebuild can lock out writers
    for periods that are unacceptably long for a production system.
   </para>

   <para>
    <productname>PostgreSQL</> supports rebuilding indexes with minimum locking
    of writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</> option of <command>REINDEX</>. When this option
    is used, <productname>PostgreSQL</> must perform two scans of the table
    for each index that needs to be rebuild and in addition it must wait for
    all existing transactions that could potentially use the index to
    terminate. This method requires more total work than a standard index
    rebuild and takes significantly longer to complete as it needs to wait
    for unfinished transactions that might modify the index. However, since
    it allows normal operations to continue while the index is rebuilt, this
    method is useful for rebuilding indexes in a production environment. Of
    course, the extra CPU, memory and I/O load imposed by the index rebuild
    may slow down other operations.
   </para>

   <para>
    The following steps occur in a concurrent index build, each in a separate
    transaction except when the new index definitions are created, where all
    the concurrent entries are created using only one transaction. Note that
    if there are multiple indexes to be rebuilt then each step loops through
    all the indexes we're rebuilding, using a separate transaction for each one.
    <command>REINDEX CONCURRENTLY</> proceeds as follows when rebuilding
    indexes:

    <orderedlist>
     <listitem>
      <para>
       A new temporary index definition is added into the catalog
       <literal>pg_index</literal>. This definition is only used to build the
       new index, and will be removed at the completion of the process. This
       step is done as a single transaction for all the indexes involved in
       this process, meaning that if <command>REINDEX CONCURRENTLY</> is
       run on a table with multiple indexes, all the catalog entries of the
       temporary indexes are created within a single transaction. A
       <entry>SHARE UPDATE EXCLUSIVE</entry> lock at session level is taken
       on the indexes being reindexed as well as its parent table to prevent
       any schema modification while processing.
      </para>
     </listitem>
     <listitem>
      <para>
       A first pass to build the index is done for each temporary entry.
       Once the index is built, its flag <literal>pg_class.isready</> is
       switched to <quote>true</> to make ready for inserts, making it
       visible to other sessions once the transaction that performed the
       build is finished. This step is done within a single transaction
       for each entry.
      </para>
     </listitem>
     <listitem>
      <para>
       Then a second pass is performed to add tuples that were added while
       the first pass build was running. One the validation of the index
       related to the temporary entry is done, a cache invalidation is done
       so as all the sessions that referenced this index in any cached plans
       will refresh them. This step is performed within a single transaction
       for each temporary entry.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>pg_class.relfilenode</> for the existing index definition
       and the temporary definition are swapped. This means that the existing
       index definition now uses the index data that we stored during the
       build, and the temporary definition is using the old index data. Again
       a cache invalidation is performed to refresh any sessions that may refer
       to the previous index definition. Note that at this point
       <literal>pg_class.indisvalid</> is not switched to <quote>true</>,
       making the temporary index definition ignored by any read query, for
       the sake of toast indexes that can only use one single index in ready
       state at the same time. During the swap an exclusive lock is taken
       on the index and its temporary entry.
      </para>
     </listitem>
     <listitem>
      <para>
       Temporary entries have <literal>pg_class.isready</> switched to
       <quote>false</> to prevent any new tuple insertions. This step
       is done within a single transaction for each temporary entry.
      </para>
     <listitem>
      <para>
       The temporary index definition and its data (which is now the
       data for the old index) are dropped. This step is done within
       a single transaction for each temporary entry.
      </para>
     </listitem>
     <listitem>
      <para>
       The <entry>SHARE UPDATE EXCLUSIVE</entry> session lock is released
       for all the indexes processed as well as their parent tables.
      </para>
     </listitem>
    </orderedlist>
   </para>

   <para>
    If a problem arises while rebuilding the indexes, such as a
    uniqueness violation in a unique index, the <command>REINDEX</>
    command will fail but leave behind an <quote>invalid</> new index on top
    of the existing one. This index will be ignored for querying purposes
    because it might be incomplete; however it will still consume update
    overhead. The <application>psql</> <command>\d</> command will report
    such an index as <literal>INVALID</>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers
--------+---------+-----------
 col    | integer |
Indexes:
    "idx" btree (col)
    "idx_cct" btree (col) INVALID
</programlisting>

    The recommended recovery method in such cases is to drop the concurrent
    index and try again to perform <command>REINDEX CONCURRENTLY</>.
    The concurrent index created during the processing has a name finishing by
    the suffix cct. If a concurrent index is based on a <literal>PRIMARY KEY</>
    or an exclude constraint is marked as invalid. It can be dropped with
    <literal>ALTER TABLE DROP CONSTRAINT</>. This is also the case of
    <literal>UNIQUE</> indexes using constraints. Other indexes can be
    dropped using <literal>DROP INDEX</> including invalid toast indexes.
   </para>

   <para>
    Regular index builds permit other regular index builds on the same
    table to occur in parallel, but only one concurrent index build can
    occur on a table at a time. In both cases, no other types of schema
    modification on the table are allowed meanwhile.  Another difference
    is that a regular <command>REINDEX TABLE</> or <command>REINDEX INDEX</>
    command can be performed within a transaction block, but
    <command>REINDEX CONCURRENTLY</> cannot. <command>REINDEX DATABASE</> is
    by default not allowed to run inside a transaction block, so in this case
    <command>CONCURRENTLY</> is not supported.
   </para>

   <para>
    Invalid indexes of toast relations can be dropped if a failure occurred
    during <command>REINDEX CONCURRENTLY</>. Valid indexes, being unique
    for a given toast relation, cannot be dropped.
   </para>

   <para>
    <command>REINDEX DATABASE</command> used with <command>CONCURRENTLY
    </command> rebuilds concurrently only the non-system relations. System
    relations are rebuilt with a non-concurrent context. Toast indexes are
    rebuilt concurrently if the relation they depend on is a non-system
    relation.
   </para>

   <para>
    <command>REINDEX</command> uses <literal>ACCESS EXCLUSIVE</literal> lock
    on all the relations involved during operation. When
    <command>CONCURRENTLY</command> is specified, the operation is done with
    <literal>SHARE UPDATE EXCLUSIVE</literal> except when an index and its
    concurrent entry are swapped where a <literal>ACCESS EXCLUSIVE</literal>
    lock is taken on the parent relation.
   </para>

   <para>
    <command>REINDEX SYSTEM</command> does not support
    <command>CONCURRENTLY</command>.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   Rebuild a single index:

<programlisting>
REINDEX INDEX my_index;
</programlisting>
  </para>

  <para>
   Rebuild all the indexes on the table <literal>my_table</literal>:

<programlisting>
REINDEX TABLE my_table;
</programlisting>
  </para>

  <para>
   Rebuild all indexes in a particular database, without trusting the
   system indexes to be valid already:

<programlisting>
$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
</programlisting>
  </para>

  <para>
   Rebuild a table while authorizing read and write operations on involved
   relations when performed:

<programlisting>
REINDEX TABLE CONCURRENTLY my_broken_table;
</programlisting>
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibility</title>

  <para>
   There is no <command>REINDEX</command> command in the SQL standard.
  </para>
 </refsect1>
</refentry>
